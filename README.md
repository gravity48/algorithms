# Алгоритмы и структуры данных

## Структуры данных
Структуры данных - это способ организации информации для более эффективного использования.
Стоит отметить, что к структуры данных в первую очередь нужны человеку, компьютеру достаточно 
дать ссылку на адрес в памяти. Когда оцениваем эффективность работы с структурой данных подходим 
с точки зрения базовых операций с ней (crud).  

Структуры данных существуют линейные и нелинейные. 
Примеры линейных структур данных: массивы, списки, очереди, стеки.

### Линейные структуры данных
Линейные структуры данных - упорядоченные структуры, в которых адрес элемента однозначно
определяется его номером

### Массивы

Структура данных, которая представлена набором однотипных данных. В случае, когда мы хотим хранить 
разнородные данные в этом случае есть смысл хранить массив указателей. Данные хранятся в памяти 
последовательно, а значит нам нужен указатель на начало + длина массива, чтобы не выйти за пределы.

Главным достоинством массивов является доступ к элементу массива по его индексу. Кроме того, c помощью
массивов можно реализовать абстрактную структуру данных - стэк.

Из существенных недостатков, чтобы добавить элементы необходимо заново переопределять в памяти массив,
в связи с чем в настоящее время задействуются саморасширяемые массивы, которые используют память 
с т.н. запасом для вставки новых элементов. При их использовании стоит понимать, что при добавлении 
элементов и последующем их удалении память не освобождается самостоятельно и требуется вручную
вызывать методы уменьшения его размера. Еще одним недостатком является его сортировка, когда (допустим),
мы храним в массивах крупные по памяти элементы, то вынуждены перемещать крупные объемы памяти, что 
не эффективно. 

Одним из вариантов реализации массива в C++ это vector. Однако, эта реализация позволяет свободно 
выходить за его пределы, что несет за собой риски доступа/изменения произвольной памяти.


### Списки

Структура данных, которая состоит из элементов, содержащих помимо собственных данных ссылки на 
следующий и/или предыдущий элемент списка. Для удобства работы со списком необходимо хранить хвост,
голову и размер списка. Размер в свою очередь может помочь со стратегией обхода. Списки могут быть
односвязанными и двухсвязанными. Односвязанный список - меньше оверхэда по памяти.

Достоинства списка - легко добавлять в начало и в конец списка. Соответственно и сортировка будет
достаточно быстрой, потому что требуется переставлять между собой только указатели.

Недостатки - доступ к произвольному элементу списка по индексу O(n), среднее O(n/2). Кроме того, если
хранить в списках маленькие данные (например массив целых чисел), то оверхэд по памяти составит 
до 3-х раз! (24 байта). Нужно понимать, что за удобство и скорость работы с структурой данных 
мы расплачиваемся 

Списки ложатся в основу таких абстрактных типов данных как: кольцевые буфферы, очередь, 
double-ended-queue. Кольцевой буффер - когда конец списка является его началом, в таком случае 
вводиться понятие барьерный элемент. 

## Нелинейные структуры данных

Нелинейные структуры данных - это структуры данных, у которых связи между элементами зависят 
от выполнения определенных условий.

### Hash-таблицы
 
Тип данных позволяющий хранить пары вида «(ключ, значение)» и поддерживающий операции добавления
пары, а также поиска и удаления пары по ключу. В библиотеке C++ он реализован на красно-черном дереве,
однако в python используется разреженный массив, который увеличивается в зависимости от размера словаря
с целью того чтобы не допустить коллизий. Стоит понимать, что такой подход в python эффективен для 
хранения небольшого количества элементов, если мы хотим хранить сведения более чем о 1000 элементах
стоит использовать другую структуру данных. Бакет - набор элементов хеш таблицы с близкими,
совпадающими значениями хэш функции.

Преимущество использования этой структуры данных заключается в том, что поиск удаление вставка пары 
по ключу занимает O(1). В C++ из-за особенностей реализации через дерево O(logn)

Недостатки - коллизии и сложное вычисление хэш функции, проблемы с деградацией по мере роста.
Залог успеха структуры данных хорошая хэш функция, а ее вычисление ресурсозатратно. Коллизия - 
ситуация, когда для различных ключей получается одно и то же хеш-значение. В Python коллизии 
разрешаются путем смещения в разреженном массиве. 


### Деревья

Структура данных состоящих из узлов и соединяющих их направленных ребер. С помощью деревьев удобно
отображать отношения подчиненности. У деревьев есть множество различных реализаций рассмотрим
наиболее популярные из них. Высота - это расстояние от корня до листа. Обход дерева O(n). 

Преимущества - нет проблем с деградацией.

Недостатки - оверхед по памяти для хранения данных на дочерние узлы и родительские. Например 
для двоичного дерева поиска - указатели на два дочерних узла + родителя (Хранение массива int 
оверхед почти в 4 раза)

### Двоичное дерево поиска

Дерево которое используется для представления множества данных, которые ищуться по уникальному, 
только им присущему ключу. Основное требование - все ключи в левом поддереве меньше ключа t[i], 
а ключи в правом поддереве больше ключа t[i]. Поиск/удаление/вставка - O(logn).

Недостатки - чтобы соответствовать требованиям по вычислительной сложности, дерево должно быть
идеально сбалансировано.

### AVL деревья

Дерево является идеально сбалансированным тогда и только тогда когда для каждого его узла высота 
его двух поддеревьев различается не более чем на 1.

Важным отличием AVL дерева является наличие процедуры балансировки, вызываемой после каждого 
добавления или удаления узла. Суть процедуры балансировки - если высота отличаются на 1, выполняется
левый или правый поворот. При этом не столь строгие правила позволяют реже выполнять процедуру 
поворота.

### Красно-черные деревья
Является разновидностью бинарного дерева поиска. Время поиска вставки и удаления узла для 
красно-черного дерева O(logn). Красно-черные деревья хорошей самобалансирующейся структурой которые 
часто используются в базе данных, осуществляется поиск в файловых системах ext* и NTFS.

### Кучи
Кучи - двоичные деревья, для которых у каждого родительского узла есть меньше чем или равное 
значение любому из его детей. Эта реализация использует массивы, для которых heap[k] <= heap[2*k+1] 
и heap[k] <= heap[2*k+2] для всех k, считая элементы от нуля. Для сравнения, несуществующие 
элементы считаются бесконечными. Интересным свойством кучи является то, что ее наименьшим элементом 
всегда является корень, heap[0].

